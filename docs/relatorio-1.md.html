<!DOCTYPE html>
<html>
  <head>
      <meta charset="utf-8" />
      <title>relatorio-1</title>
      <style>.markdown-preview, .markdown-preview[data-use-github-style] { font-family: 'Helvetica Neue', Helvetica, 'Segoe UI', Arial, freesans, sans-serif; font-size: 16px; line-height: 1.6; word-wrap: break-word; overflow: scroll; box-sizing: border-box; padding: 20px; background-color: rgb(255, 255, 255); }
.markdown-preview > :first-child, .markdown-preview[data-use-github-style] > :first-child { margin-top: 0px !important; }
.markdown-preview > :last-child, .markdown-preview[data-use-github-style] > :last-child { margin-bottom: 0px !important; }
.markdown-preview a:not([href]), .markdown-preview[data-use-github-style] a:not([href]) { color: inherit; text-decoration: none; }
.markdown-preview .absent, .markdown-preview[data-use-github-style] .absent { color: rgb(204, 0, 0); }
.markdown-preview .anchor, .markdown-preview[data-use-github-style] .anchor { position: absolute; top: 0px; left: 0px; display: block; padding-right: 6px; padding-left: 30px; margin-left: -30px; }
.markdown-preview .anchor:focus, .markdown-preview[data-use-github-style] .anchor:focus { outline: none; }
.markdown-preview h1, .markdown-preview[data-use-github-style] h1, .markdown-preview h2, .markdown-preview[data-use-github-style] h2, .markdown-preview h3, .markdown-preview[data-use-github-style] h3, .markdown-preview h4, .markdown-preview[data-use-github-style] h4, .markdown-preview h5, .markdown-preview[data-use-github-style] h5, .markdown-preview h6, .markdown-preview[data-use-github-style] h6 { position: relative; margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; }
.markdown-preview h1 .octicon-link, .markdown-preview[data-use-github-style] h1 .octicon-link, .markdown-preview h2 .octicon-link, .markdown-preview[data-use-github-style] h2 .octicon-link, .markdown-preview h3 .octicon-link, .markdown-preview[data-use-github-style] h3 .octicon-link, .markdown-preview h4 .octicon-link, .markdown-preview[data-use-github-style] h4 .octicon-link, .markdown-preview h5 .octicon-link, .markdown-preview[data-use-github-style] h5 .octicon-link, .markdown-preview h6 .octicon-link, .markdown-preview[data-use-github-style] h6 .octicon-link { display: none; color: rgb(0, 0, 0); vertical-align: middle; }
.markdown-preview h1:hover .anchor, .markdown-preview[data-use-github-style] h1:hover .anchor, .markdown-preview h2:hover .anchor, .markdown-preview[data-use-github-style] h2:hover .anchor, .markdown-preview h3:hover .anchor, .markdown-preview[data-use-github-style] h3:hover .anchor, .markdown-preview h4:hover .anchor, .markdown-preview[data-use-github-style] h4:hover .anchor, .markdown-preview h5:hover .anchor, .markdown-preview[data-use-github-style] h5:hover .anchor, .markdown-preview h6:hover .anchor, .markdown-preview[data-use-github-style] h6:hover .anchor { padding-left: 8px; margin-left: -30px; text-decoration: none; }
.markdown-preview h1:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h1:hover .anchor .octicon-link, .markdown-preview h2:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h2:hover .anchor .octicon-link, .markdown-preview h3:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h3:hover .anchor .octicon-link, .markdown-preview h4:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h4:hover .anchor .octicon-link, .markdown-preview h5:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h5:hover .anchor .octicon-link, .markdown-preview h6:hover .anchor .octicon-link, .markdown-preview[data-use-github-style] h6:hover .anchor .octicon-link { display: inline-block; }
.markdown-preview h1 tt, .markdown-preview[data-use-github-style] h1 tt, .markdown-preview h2 tt, .markdown-preview[data-use-github-style] h2 tt, .markdown-preview h3 tt, .markdown-preview[data-use-github-style] h3 tt, .markdown-preview h4 tt, .markdown-preview[data-use-github-style] h4 tt, .markdown-preview h5 tt, .markdown-preview[data-use-github-style] h5 tt, .markdown-preview h6 tt, .markdown-preview[data-use-github-style] h6 tt, .markdown-preview h1 code, .markdown-preview[data-use-github-style] h1 code, .markdown-preview h2 code, .markdown-preview[data-use-github-style] h2 code, .markdown-preview h3 code, .markdown-preview[data-use-github-style] h3 code, .markdown-preview h4 code, .markdown-preview[data-use-github-style] h4 code, .markdown-preview h5 code, .markdown-preview[data-use-github-style] h5 code, .markdown-preview h6 code, .markdown-preview[data-use-github-style] h6 code { font-size: inherit; }
.markdown-preview h1, .markdown-preview[data-use-github-style] h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
.markdown-preview h1 .anchor, .markdown-preview[data-use-github-style] h1 .anchor { line-height: 1; }
.markdown-preview h2, .markdown-preview[data-use-github-style] h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); }
.markdown-preview h2 .anchor, .markdown-preview[data-use-github-style] h2 .anchor { line-height: 1; }
.markdown-preview h3, .markdown-preview[data-use-github-style] h3 { font-size: 1.5em; line-height: 1.43; }
.markdown-preview h3 .anchor, .markdown-preview[data-use-github-style] h3 .anchor { line-height: 1.2; }
.markdown-preview h4, .markdown-preview[data-use-github-style] h4 { font-size: 1.25em; }
.markdown-preview h4 .anchor, .markdown-preview[data-use-github-style] h4 .anchor { line-height: 1.2; }
.markdown-preview h5, .markdown-preview[data-use-github-style] h5 { font-size: 1em; }
.markdown-preview h5 .anchor, .markdown-preview[data-use-github-style] h5 .anchor { line-height: 1.1; }
.markdown-preview h6, .markdown-preview[data-use-github-style] h6 { font-size: 1em; color: rgb(119, 119, 119); }
.markdown-preview h6 .anchor, .markdown-preview[data-use-github-style] h6 .anchor { line-height: 1.1; }
.markdown-preview p, .markdown-preview[data-use-github-style] p, .markdown-preview blockquote, .markdown-preview[data-use-github-style] blockquote, .markdown-preview ul, .markdown-preview[data-use-github-style] ul, .markdown-preview ol, .markdown-preview[data-use-github-style] ol, .markdown-preview dl, .markdown-preview[data-use-github-style] dl, .markdown-preview table, .markdown-preview[data-use-github-style] table, .markdown-preview pre, .markdown-preview[data-use-github-style] pre { margin-top: 0px; margin-bottom: 16px; }
.markdown-preview hr, .markdown-preview[data-use-github-style] hr { height: 4px; padding: 0px; margin: 16px 0px; border: 0px none; background-color: rgb(231, 231, 231); }
.markdown-preview ul, .markdown-preview[data-use-github-style] ul, .markdown-preview ol, .markdown-preview[data-use-github-style] ol { padding-left: 2em; }
.markdown-preview ul.no-list, .markdown-preview[data-use-github-style] ul.no-list, .markdown-preview ol.no-list, .markdown-preview[data-use-github-style] ol.no-list { padding: 0px; list-style-type: none; }
.markdown-preview ul ul, .markdown-preview[data-use-github-style] ul ul, .markdown-preview ul ol, .markdown-preview[data-use-github-style] ul ol, .markdown-preview ol ol, .markdown-preview[data-use-github-style] ol ol, .markdown-preview ol ul, .markdown-preview[data-use-github-style] ol ul { margin-top: 0px; margin-bottom: 0px; }
.markdown-preview li > p, .markdown-preview[data-use-github-style] li > p { margin-top: 16px; }
.markdown-preview dl, .markdown-preview[data-use-github-style] dl { padding: 0px; }
.markdown-preview dl dt, .markdown-preview[data-use-github-style] dl dt { padding: 0px; margin-top: 16px; font-size: 1em; font-style: italic; font-weight: bold; }
.markdown-preview dl dd, .markdown-preview[data-use-github-style] dl dd { padding: 0px 16px; margin-bottom: 16px; }
.markdown-preview blockquote, .markdown-preview[data-use-github-style] blockquote { padding: 0px 15px; color: rgb(119, 119, 119); border-left-width: 4px; border-left-style: solid; border-left-color: rgb(221, 221, 221); }
.markdown-preview blockquote > :first-child, .markdown-preview[data-use-github-style] blockquote > :first-child { margin-top: 0px; }
.markdown-preview blockquote > :last-child, .markdown-preview[data-use-github-style] blockquote > :last-child { margin-bottom: 0px; }
.markdown-preview table, .markdown-preview[data-use-github-style] table { display: block; width: 100%; overflow: auto; word-break: normal; }
.markdown-preview table th, .markdown-preview[data-use-github-style] table th { font-weight: bold; }
.markdown-preview table th, .markdown-preview[data-use-github-style] table th, .markdown-preview table td, .markdown-preview[data-use-github-style] table td { padding: 6px 13px; border: 1px solid rgb(221, 221, 221); }
.markdown-preview table tr, .markdown-preview[data-use-github-style] table tr { border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); }
.markdown-preview table tr:nth-child(2n), .markdown-preview[data-use-github-style] table tr:nth-child(2n) { background-color: rgb(248, 248, 248); }
.markdown-preview img, .markdown-preview[data-use-github-style] img { max-width: 100%; box-sizing: border-box; }
.markdown-preview .emoji, .markdown-preview[data-use-github-style] .emoji { max-width: none; }
.markdown-preview span.frame, .markdown-preview[data-use-github-style] span.frame { display: block; overflow: hidden; }
.markdown-preview span.frame > span, .markdown-preview[data-use-github-style] span.frame > span { display: block; float: left; width: auto; padding: 7px; margin: 13px 0px 0px; overflow: hidden; border: 1px solid rgb(221, 221, 221); }
.markdown-preview span.frame span img, .markdown-preview[data-use-github-style] span.frame span img { display: block; float: left; }
.markdown-preview span.frame span span, .markdown-preview[data-use-github-style] span.frame span span { display: block; padding: 5px 0px 0px; clear: both; color: rgb(51, 51, 51); }
.markdown-preview span.align-center, .markdown-preview[data-use-github-style] span.align-center { display: block; overflow: hidden; clear: both; }
.markdown-preview span.align-center > span, .markdown-preview[data-use-github-style] span.align-center > span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: center; }
.markdown-preview span.align-center span img, .markdown-preview[data-use-github-style] span.align-center span img { margin: 0px auto; text-align: center; }
.markdown-preview span.align-right, .markdown-preview[data-use-github-style] span.align-right { display: block; overflow: hidden; clear: both; }
.markdown-preview span.align-right > span, .markdown-preview[data-use-github-style] span.align-right > span { display: block; margin: 13px 0px 0px; overflow: hidden; text-align: right; }
.markdown-preview span.align-right span img, .markdown-preview[data-use-github-style] span.align-right span img { margin: 0px; text-align: right; }
.markdown-preview span.float-left, .markdown-preview[data-use-github-style] span.float-left { display: block; float: left; margin-right: 13px; overflow: hidden; }
.markdown-preview span.float-left span, .markdown-preview[data-use-github-style] span.float-left span { margin: 13px 0px 0px; }
.markdown-preview span.float-right, .markdown-preview[data-use-github-style] span.float-right { display: block; float: right; margin-left: 13px; overflow: hidden; }
.markdown-preview span.float-right > span, .markdown-preview[data-use-github-style] span.float-right > span { display: block; margin: 13px auto 0px; overflow: hidden; text-align: right; }
.markdown-preview code, .markdown-preview[data-use-github-style] code, .markdown-preview tt, .markdown-preview[data-use-github-style] tt { padding: 0.2em 0px; margin: 0px; font-size: 85%; border-radius: 3px; background-color: rgba(0, 0, 0, 0.0392157); }
.markdown-preview code::before, .markdown-preview[data-use-github-style] code::before, .markdown-preview tt::before, .markdown-preview[data-use-github-style] tt::before, .markdown-preview code::after, .markdown-preview[data-use-github-style] code::after, .markdown-preview tt::after, .markdown-preview[data-use-github-style] tt::after { letter-spacing: -0.2em; content: ' '; }
.markdown-preview code br, .markdown-preview[data-use-github-style] code br, .markdown-preview tt br, .markdown-preview[data-use-github-style] tt br { display: none; }
.markdown-preview del code, .markdown-preview[data-use-github-style] del code { text-decoration: inherit; }
.markdown-preview pre > code, .markdown-preview[data-use-github-style] pre > code { padding: 0px; margin: 0px; font-size: 100%; word-break: normal; white-space: pre; border: 0px; background: transparent; }
.markdown-preview .highlight, .markdown-preview[data-use-github-style] .highlight { margin-bottom: 16px; }
.markdown-preview .highlight pre, .markdown-preview[data-use-github-style] .highlight pre, .markdown-preview pre, .markdown-preview[data-use-github-style] pre { padding: 16px; overflow: auto; font-size: 85%; line-height: 1.45; border-radius: 3px; background-color: rgb(247, 247, 247); }
.markdown-preview .highlight pre, .markdown-preview[data-use-github-style] .highlight pre { margin-bottom: 0px; word-break: normal; }
.markdown-preview pre, .markdown-preview[data-use-github-style] pre { word-wrap: normal; }
.markdown-preview pre code, .markdown-preview[data-use-github-style] pre code, .markdown-preview pre tt, .markdown-preview[data-use-github-style] pre tt { display: inline; max-width: initial; padding: 0px; margin: 0px; overflow: initial; line-height: inherit; word-wrap: normal; border: 0px; background-color: transparent; }
.markdown-preview pre code::before, .markdown-preview[data-use-github-style] pre code::before, .markdown-preview pre tt::before, .markdown-preview[data-use-github-style] pre tt::before, .markdown-preview pre code::after, .markdown-preview[data-use-github-style] pre code::after, .markdown-preview pre tt::after, .markdown-preview[data-use-github-style] pre tt::after { content: normal; }
.markdown-preview kbd, .markdown-preview[data-use-github-style] kbd { display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: rgb(85, 85, 85); vertical-align: middle; border-style: solid; border-width: 1px; border-color: rgb(204, 204, 204) rgb(204, 204, 204) rgb(187, 187, 187); border-radius: 3px; box-shadow: rgb(187, 187, 187) 0px -1px 0px inset; background-color: rgb(252, 252, 252); }
.markdown-preview, .markdown-preview[data-use-github-style], .markdown-preview code, .markdown-preview[data-use-github-style] code { color: rgb(51, 51, 51); }
.markdown-preview h1, .markdown-preview[data-use-github-style] h1, .markdown-preview h2, .markdown-preview[data-use-github-style] h2, .markdown-preview h3, .markdown-preview[data-use-github-style] h3, .markdown-preview h4, .markdown-preview[data-use-github-style] h4, .markdown-preview h5, .markdown-preview[data-use-github-style] h5, .markdown-preview h6, .markdown-preview[data-use-github-style] h6 { -webkit-font-smoothing: antialiased; cursor: text; }
.markdown-preview > h1:first-child, .markdown-preview[data-use-github-style] > h1:first-child, .markdown-preview > h1:first-child + h2, .markdown-preview[data-use-github-style] > h1:first-child + h2, .markdown-preview > h2:first-child, .markdown-preview[data-use-github-style] > h2:first-child, .markdown-preview > h3:first-child, .markdown-preview[data-use-github-style] > h3:first-child, .markdown-preview > h4:first-child, .markdown-preview[data-use-github-style] > h4:first-child, .markdown-preview > h5:first-child, .markdown-preview[data-use-github-style] > h5:first-child, .markdown-preview > h6:first-child, .markdown-preview[data-use-github-style] > h6:first-child { margin-top: 0px; padding-top: 0px; }
.markdown-preview a, .markdown-preview[data-use-github-style] a, .markdown-preview a code, .markdown-preview[data-use-github-style] a code { color: rgb(65, 131, 196); }
.markdown-preview a:first-child h1, .markdown-preview[data-use-github-style] a:first-child h1, .markdown-preview a:first-child h2, .markdown-preview[data-use-github-style] a:first-child h2, .markdown-preview a:first-child h3, .markdown-preview[data-use-github-style] a:first-child h3, .markdown-preview a:first-child h4, .markdown-preview[data-use-github-style] a:first-child h4, .markdown-preview a:first-child h5, .markdown-preview[data-use-github-style] a:first-child h5, .markdown-preview a:first-child h6, .markdown-preview[data-use-github-style] a:first-child h6 { margin-top: 0px; padding-top: 0px; }
.markdown-preview h1 + p, .markdown-preview[data-use-github-style] h1 + p, .markdown-preview h2 + p, .markdown-preview[data-use-github-style] h2 + p, .markdown-preview h3 + p, .markdown-preview[data-use-github-style] h3 + p, .markdown-preview h4 + p, .markdown-preview[data-use-github-style] h4 + p, .markdown-preview h5 + p, .markdown-preview[data-use-github-style] h5 + p, .markdown-preview h6 + p, .markdown-preview[data-use-github-style] h6 + p { margin-top: 0px; }
.markdown-preview li p.first, .markdown-preview[data-use-github-style] li p.first { display: inline-block; }
.markdown-preview ul li > :first-child, .markdown-preview[data-use-github-style] ul li > :first-child, .markdown-preview ol li > :first-child, .markdown-preview[data-use-github-style] ol li > :first-child, .markdown-preview ul li ul:first-of-type, .markdown-preview[data-use-github-style] ul li ul:first-of-type, .markdown-preview ol li ul:first-of-type, .markdown-preview[data-use-github-style] ol li ul:first-of-type { margin-top: 0px; }
.markdown-preview ol > li, .markdown-preview[data-use-github-style] ol > li { list-style-type: decimal; }
.markdown-preview ul > li, .markdown-preview[data-use-github-style] ul > li { list-style-type: disc; }
.markdown-preview dl dt:first-child, .markdown-preview[data-use-github-style] dl dt:first-child { padding: 0px; }
.markdown-preview dl dt > :first-child, .markdown-preview[data-use-github-style] dl dt > :first-child { margin-top: 0px; }
.markdown-preview dl dt > :last-child, .markdown-preview[data-use-github-style] dl dt > :last-child { margin-bottom: 0px; }
.markdown-preview dl dd > :first-child, .markdown-preview[data-use-github-style] dl dd > :first-child { margin-top: 0px; }
.markdown-preview dl dd > :last-child, .markdown-preview[data-use-github-style] dl dd > :last-child { margin-bottom: 0px; }
.markdown-preview blockquote p, .markdown-preview[data-use-github-style] blockquote p { font-size: 16px; line-height: 1.5; }
.markdown-preview pre.editor-colors, .markdown-preview[data-use-github-style] pre.editor-colors { padding: 16px; overflow: auto; font-size: 84%; line-height: 1.45; border-radius: 3px; background-color: rgb(29, 31, 33); }
.markdown-preview pre.editor-colors, .markdown-preview[data-use-github-style] pre.editor-colors { margin-bottom: 16px; word-break: normal; }
.markdown-preview code, .markdown-preview[data-use-github-style] code, .markdown-preview tt, .markdown-preview[data-use-github-style] tt, .markdown-preview pre.editor-colors, .markdown-preview[data-use-github-style] pre.editor-colors { font-family: Consolas, 'Liberation Mono', Courier, monospace; }
.markdown-preview .emoji, .markdown-preview[data-use-github-style] .emoji { height: 20px; width: 20px; }
.bracket-matcher .region {
  border-bottom: 1px dotted lime;
  position: absolute;
}

pre.editor-colors,
.host {
  background-color: #1d1f21;
  color: #c5c8c6;
}
pre.editor-colors .invisible-character,
.host .invisible-character {
  color: rgba(197, 200, 198, 0.2);
}
pre.editor-colors .indent-guide,
.host .indent-guide {
  color: rgba(197, 200, 198, 0.2);
}
pre.editor-colors .wrap-guide,
.host .wrap-guide {
  background-color: rgba(197, 200, 198, 0.1);
}
pre.editor-colors .gutter,
.host .gutter {
  background-color: #292c2f;
}
pre.editor-colors .gutter .cursor-line,
.host .gutter .cursor-line {
  background-color: rgba(255, 255, 255, 0.14);
}
pre.editor-colors .line-number.cursor-line-no-selection,
.host .line-number.cursor-line-no-selection {
  background-color: rgba(255, 255, 255, 0.14);
}
pre.editor-colors .gutter .line-number.folded,
.host .gutter .line-number.folded,
pre.editor-colors .gutter .line-number:after,
.host .gutter .line-number:after,
pre.editor-colors .fold-marker:after,
.host .fold-marker:after {
  color: #fba0e3;
}
pre.editor-colors .invisible,
.host .invisible {
  color: #c5c8c6;
}
pre.editor-colors .cursor,
.host .cursor {
  border-color: #ffffff;
}
pre.editor-colors .selection .region,
.host .selection .region {
  background-color: #444444;
}
pre.editor-colors .source.gfm,
.host .source.gfm {
  color: #999;
}
pre.editor-colors .gfm .markup.heading,
.host .gfm .markup.heading {
  color: #eee;
}
pre.editor-colors .gfm .link,
.host .gfm .link {
  color: #555;
}
pre.editor-colors .gfm .variable.list,
.host .gfm .variable.list,
pre.editor-colors .gfm .support.quote,
.host .gfm .support.quote {
  color: #555;
}
pre.editor-colors .gfm .link .entity,
.host .gfm .link .entity {
  color: #ddd;
}
pre.editor-colors .gfm .raw,
.host .gfm .raw {
  color: #aaa;
}
pre.editor-colors .markdown .paragraph,
.host .markdown .paragraph {
  color: #999;
}
pre.editor-colors .markdown .heading,
.host .markdown .heading {
  color: #eee;
}
pre.editor-colors .markdown .raw,
.host .markdown .raw {
  color: #aaa;
}
pre.editor-colors .markdown .link,
.host .markdown .link {
  color: #555;
}
pre.editor-colors .markdown .link .string,
.host .markdown .link .string {
  color: #555;
}
pre.editor-colors .markdown .link .string.title,
.host .markdown .link .string.title {
  color: #ddd;
}
.bracket-matcher .region {
  border-bottom: 1px solid #f8de7e;
  margin-top: -1px;
  opacity: .7;
}
.comment {
  color: #7C7C7C;
}
.entity {
  color: #FFD2A7;
}
.entity.name.type {
  text-decoration: underline;
  color: #FFFFB6;
}
.entity.other.inherited-class {
  color: #9B5C2E;
}
.keyword {
  color: #96CBFE;
}
.keyword.control {
  color: #96CBFE;
}
.keyword.operator {
  color: #EDEDED;
}
.storage {
  color: #CFCB90;
}
.storage.modifier {
  color: #96CBFE;
}
.constant {
  color: #99CC99;
}
.constant.numeric {
  color: #FF73FD;
}
.variable {
  color: #C6C5FE;
}
.invalid.deprecated {
  text-decoration: underline;
  color: #FD5FF1;
}
.invalid.illegal {
  color: #FD5FF1;
  background-color: rgba(86, 45, 86, 0.75);
}
.string .source,
.string .meta.embedded.line {
  color: #EDEDED;
}
.string .punctuation.section.embedded {
  color: #00A0A0;
}
.string .punctuation.section.embedded .source {
  color: #00A0A0;
}
.string {
  color: #A8FF60;
}
.string .constant {
  color: #00A0A0;
}
.string.regexp {
  color: #E9C062;
}
.string.regexp .constant.character.escape,
.string.regexp .source.ruby.embedded,
.string.regexp .string.regexp.arbitrary-repetition {
  color: #FF8000;
}
.string.regexp.group {
  color: #C6A24F;
  background-color: rgba(255, 255, 255, 0.06);
}
.string.regexp.character-class {
  color: #B18A3D;
}
.string .variable {
  color: #8A9A95;
}
.support {
  color: #FFFFB6;
}
.support.function {
  color: #DAD085;
}
.support.constant {
  color: #FFD2A7;
}
.support.type.property-name.css {
  color: #EDEDED;
}
.source .entity.name.tag,
.source .punctuation.tag {
  color: #96CBFE;
}
.source .entity.other.attribute-name {
  color: #C6C5FE;
}
.entity.other.attribute-name {
  color: #C6C5FE;
}
.entity.name.tag.namespace,
.entity.other.attribute-name.namespace {
  color: #E18964;
}
.meta.preprocessor.c {
  color: #8996A8;
}
.meta.preprocessor.c .keyword {
  color: #AFC4DB;
}
.meta.cast {
  color: #676767;
}
.meta.sgml.html .meta.doctype,
.meta.sgml.html .meta.doctype .entity,
.meta.sgml.html .meta.doctype .string,
.meta.xml-processing,
.meta.xml-processing .entity,
.meta.xml-processing .string {
  color: #494949;
}
.meta.tag .entity,
.meta.tag > .punctuation,
.meta.tag.inline .entity {
  color: #C6C5FE;
}
.meta.tag .name,
.meta.tag.inline .name,
.meta.tag > .punctuation {
  color: #96CBFE;
}
.meta.selector.css .entity.name.tag {
  text-decoration: underline;
  color: #96CBFE;
}
.meta.selector.css .entity.other.attribute-name.tag.pseudo-class {
  color: #8F9D6A;
}
.meta.selector.css .entity.other.attribute-name.id {
  color: #8B98AB;
}
.meta.selector.css .entity.other.attribute-name.class {
  color: #62B1FE;
}
.meta.property-group .support.constant.property-value.css,
.meta.property-value .support.constant.property-value.css {
  color: #F9EE98;
}
.meta.preprocessor.at-rule .keyword.control.at-rule {
  color: #8693A5;
}
.meta.property-value .support.constant.named-color.css,
.meta.property-value .constant {
  color: #87C38A;
}
.meta.constructor.argument.css {
  color: #8F9D6A;
}
.meta.diff,
.meta.diff.header {
  color: #F8F8F8;
  background-color: #0E2231;
}
.meta.separator {
  color: #60A633;
  background-color: #242424;
}
.meta.line.entry.logfile,
.meta.line.exit.logfile {
  background-color: rgba(238, 238, 238, 0.16);
}
.meta.line.error.logfile {
  background-color: #751012;
}
</style>
  </head>
  <body class='markdown-preview'><h1 id="so-ii-relat-rio-do-trabalho-sobre-m-todos-de-busca-parte-1">SO II - Relatório do Trabalho sobre Métodos de Busca - Parte 1</h1>
<ul>
<li>Semestre: 2015-2</li>
<li>Aluno: Quenio Cesar Machado dos Santos</li>
<li>Matrícula: 14100868</li>
</ul>
<h2 id="enunciado">Enunciado</h2>
<p>Implementação do jogo Gomoku usando o algoritmo de busca MinMax com podas. Nesta primeira parte do trabalho será avaliado:</p>
<ul>
<li>a implementação do modelo de estados e do jogo - ver código-fonte em anexo;</li>
<li>e a definição das funções utilidade e heurísticas - ver seção Função de Pontuação (Utilidade) abaixo.</li>
</ul>
<h2 id="fun-o-de-pontua-o-utilidade-">Função de Pontuação (Utilidade)</h2>
<p>O algoritmo min-max navegada a árvore de estados do jogo para definir a utilidade de cada tabuleiro (estado do jogo), ou seja, para definir um valor (ou pontuação) que exprime quão próximo da vitória está um estado do tabuleiro relativamente a outros estados do tabuleiro que podem ser jogados.</p>
<p>Quando chega aos nós-folha desta árvore, ou seja, a um estado final do jogo, é necessário definir através de uma pontuação se um nó-folha é um resultado de vitória, perda ou empate para o jogador.</p>
<p>Porém, num jogo como o Gomoku, a árvore de estados de jogo é simplesmente muito grande para ser percorrida em tempo hábil para se fazer uma jogada. Portanto, é necessário interromper a busca em níveis superiores da árvore ou ainda eliminar alguns ramos da árvore de busca.</p>
<p>Para isto, é necessário definir algumas heurísticas que possam usar apenas o estado de jogo, representado por um único nodo da árvore, para se calcular uma pontuação que se aproxime do resultado que seria alcançado caso a sub-árvore daquele nodo fosse percorrida.</p>
<p>Desta forma, a função de utilidade (abaixo chamada &quot;score&quot;) é aquela que retorna a pontuação de um nó quando este é um nó terminal ou quando se alcançou o nível limite de busca na árvore.</p>
<p>Pode-se definí-la de forma abstrata com o código-fonte em &quot;C&quot; abaixo:</p>
<pre class="editor-colors lang-C++"><div class="line"><span class="text plain null-grammar"><span>int&nbsp;score(GameNode&nbsp;node)</span></span></div><div class="line"><span class="text plain null-grammar"><span>{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;isGameOver(node)&nbsp;?&nbsp;terminalScore(node)&nbsp;:&nbsp;heuristicScore(node);</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<h2 id="vit-ria-derrota-ou-empate">Vitória, Derrota ou Empate</h2>
<p>Para os nodos da árvore no estado terminal do jogo, a função utilidade precisa gerar apenas três valores de pontuação:</p>
<ul>
<li>um valor de vitória;</li>
<li>um valor de derrota;</li>
<li>e um valor de empate.</li>
</ul>
<p>Todos as outras pontuações geradas pela função utilidade, se não foram calculadas a partir de nodos terminais da árvore, precisam necessariamente serem menores que o valor de vitória, pois são apenas estimativas; não são baseados num estado de vitória do jogo.</p>
<p>Para o jogo Gomoku, fixamos os seguintes valores:</p>
<ul>
<li>vitória: +500;</li>
<li>derrota: -500;</li>
<li>empate: 0.</li>
</ul>
<p>Este valor foi escolhido, pois:</p>
<ul>
<li>é o número de casas do tabuleiro necessários para um jogador ganhar o jogo, multiplicado por 100.</li>
<li>o número de casas é usado para calcular a pontuação baseada em heurísticas, como descrito nas próximas seções.</li>
</ul>
<h2 id="heur-sticas">Heurísticas</h2>
<p>Como foi explicado nas seções acima, quando não é possível percorrer uma árvore de jogo até seus nodos terminais, é preciso utilizar algumas heurísticas (desenvolvidas com a experiência de jogar) para se calcular a pontuação de nodos intermediários.</p>
<p>Aqui estão algumas heurísticas que conseguimos determinar ao jogar Gomoku:</p>
<ul>
<li>Campo Limpo: quando se começa jogando, a fim de maximizar as opções de jogada, sempre é bom começar o jogo numa casa que tenha pelo menos 4 espaços em todas as direções.</li>
<li>Pontas Livres: sempre escolha aumentar uma linha que tem pontas livres do que uma linha que já está fechada em um dos lados, pois se cria a possibilidade de fechar em qualquer uma das pontas.</li>
<li>Triangulação: usar o mesmo marcador em linhas ortgonais ou diagonais cria mais opções de vitória com um número menor de jogadas e exige mais defesas do adversário, diminuindo o número de jogadas ofensivas que ele pode fazer.</li>
<li>Tracejando: Formar linhas não consecutivas (antes de fechá-las) pode torná-las imperceptíveis para o adersário se este não prestar atenção.</li>
<li>Sentinela: É sempre melhor impedir que o adversário consiga formar uma linha de quatro marcadores com pontas livres do que tentar avançar numa linha própria, pois não há como se recuperar desta situação.</li>
<li>Bloqueio Amplo: se puder bloquear em ambas as pontas de uma linha do adversário, escolha a ponta que também bloqueia outras linhas. Assim você consegue defender-se em duas situações com apenas uma jogada.</li>
</ul>
<p>As heurísticas definidas acima precisam ser traduzidas em uma função matemática que recebe o estado atual do jogo (nó da árvore) como entrada e retorna uma pontuação que exprime o quão próximo de uma vitória, derrota ou empate se encontra o jogador a partir do tabuleiro que se apresenta.</p>
<p>Além disso, esta pontuação precisa priorizar as heuristícas de acordo com cada situação, ou estado do tabuleiro, visto que elas podem aplicar-se igualmente em uma determinada posição do tabuleiro.</p>
<h2 id="a-pontua-o-baseada-em-heur-sticas">A Pontuação Baseada em Heurísticas</h2>
<p>Nesta seção, definiremos a função utilidade baseada em heurísticas que implementaremos na segunda parte do trabalho. Primeiramente, vamos definir o algoritmo. Posteriormente, vamos avaliá-lo de acordo com cada heurística.</p>
<p>Informalmente, o algoritmo pode ser descrito de forma bem resumida nos três passos a seguir:</p>
<ol>
<li>Para cada direção do tabuleiro, haverá uma pontuação associada à casa onde será feita potentialmente a próxima jogada. Esta pontuação é calculada usando o estado das casas adjacentes naquela direção do tabuleiro, considerando se a casa da próxima jogada seja sua ou do adversário.</li>
<li>O valor calculado para cada tupla (direção, jogador) é então comparado aos demais. O maior valor é considerado a pontuação associada ao estado do tabuleiro quando aquela jogada é efetuada pelo jogador.</li>
<li>Se houver mais de um valor máximo retornado em direções diferentes, se adiciona &quot;1&quot; a pontuação para cada valor máximo adicional.</li>
</ol>
<p>Em &quot;C&quot;, pode-se definir o algoritmo acima de forma abstrata:</p>
<pre class="editor-colors lang-C++"><div class="line"><span class="text plain null-grammar"><span>enum&nbsp;PlayerMaker</span></span></div><div class="line"><span class="text plain null-grammar"><span>{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;X,&nbsp;//&nbsp;Computer</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;O&nbsp;//&nbsp;Human</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div><div class="line"><span class="text plain null-grammar"><span>enum&nbsp;Direction&nbsp;{&nbsp;North,&nbsp;Northeast,&nbsp;East,&nbsp;Southeast,&nbsp;South,&nbsp;Southwest,&nbsp;West,&nbsp;Northwest&nbsp;};</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>int&nbsp;score(GameNode&nbsp;node)</span></span></div><div class="line"><span class="text plain null-grammar"><span>{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;int&nbsp;max&nbsp;=&nbsp;MIN_INT;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;int&nbsp;extra&nbsp;=&nbsp;0;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;for&nbsp;(Direction&nbsp;direction&nbsp;=&nbsp;North;&nbsp;direction&nbsp;&lt;=&nbsp;Northwest;&nbsp;direction++)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;score&nbsp;=&nbsp;score(node,&nbsp;direction,&nbsp;PlayerMaker::X);</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(score&nbsp;==&nbsp;max)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extra++;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(score&nbsp;&gt;&nbsp;max)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;=&nbsp;score;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extra&nbsp;=&nbsp;0;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;score&nbsp;=&nbsp;score(node,&nbsp;direction,&nbsp;PlayerMaker::O);</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(score&nbsp;==&nbsp;max)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extra++;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(score&nbsp;&gt;&nbsp;max)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max&nbsp;=&nbsp;score</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extra&nbsp;=&nbsp;0;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;return&nbsp;max&nbsp;+&nbsp;extra;</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>O cálculo da pontuação de cada direção do tabuleiro descrita no passo 1 acima pode ser descrito em &quot;C&quot;:</p>
<pre class="editor-colors lang-C++"><div class="line"><span class="text plain null-grammar"><span>int&nbsp;score(GameNode&nbsp;node,&nbsp;Direction&nbsp;direction,&nbsp;PlayerMaker&nbsp;marker)</span></span></div><div class="line"><span class="text plain null-grammar"><span>{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;int&nbsp;score&nbsp;=&nbsp;100;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;int&nbsp;step&nbsp;=&nbsp;1;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;int&nbsp;interval&nbsp;=&nbsp;1;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;Slot&nbsp;current&nbsp;=&nbsp;node.slot;&nbsp;&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;while&nbsp;(current&nbsp;!=&nbsp;nullptr&nbsp;&amp;&amp;&nbsp;interval&nbsp;&lt;&nbsp;5)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;previous&nbsp;=&nbsp;current</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;neighbor(current,&nbsp;direction,&nbsp;step);</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(current&nbsp;==&nbsp;nullptr&nbsp;||&nbsp;current.marker&nbsp;!=&nbsp;marker)&nbsp;//&nbsp;bloqueado</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(step&nbsp;==&nbsp;1)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Já&nbsp;bloqueado&nbsp;na&nbsp;posição&nbsp;de&nbsp;jogada.&nbsp;Nada&nbsp;para&nbsp;buscar&nbsp;nesta&nbsp;direção.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;nullptr;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(step&nbsp;&gt;&nbsp;1)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step&nbsp;=&nbsp;-1;&nbsp;//&nbsp;Chegou-se&nbsp;ao&nbsp;final&nbsp;da&nbsp;linha;&nbsp;segue&nbsp;na&nbsp;direção&nbsp;oposta.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;=&nbsp;node.slot</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score--;&nbsp;//&nbsp;Uma&nbsp;linha&nbsp;bloqueada&nbsp;deve&nbsp;valer&nbsp;menos&nbsp;que&nbsp;uma&nbsp;linha&nbsp;livre.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(current.marker&nbsp;==&nbsp;marker)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score&nbsp;+=&nbsp;100;&nbsp;//&nbsp;Pontuação&nbsp;cheia&nbsp;pois&nbsp;esta&nbsp;casa&nbsp;já&nbsp;é&nbsp;marcada.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step++;&nbsp;//&nbsp;Segue&nbsp;adiante&nbsp;no&nbsp;mesmo&nbsp;sentido&nbsp;da&nbsp;direção.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval++;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;//&nbsp;if&nbsp;(current.empty)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score&nbsp;+=&nbsp;50;&nbsp;//&nbsp;Meia-pontuação&nbsp;pois&nbsp;esta&nbsp;casa&nbsp;é&nbsp;apenas&nbsp;uma&nbsp;possibilidade.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step++;&nbsp;//&nbsp;Segue&nbsp;adiante&nbsp;no&nbsp;mesmo&nbsp;sentido&nbsp;da&nbsp;direção.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interval++;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(previous&nbsp;!=&nbsp;node.slot&nbsp;&amp;&amp;&nbsp;previous.marker&nbsp;!=&nbsp;current.marker)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score++;&nbsp;//&nbsp;Tracejados&nbsp;tem&nbsp;pontos&nbsp;mais&nbsp;altos&nbsp;porque&nbsp;eles&nbsp;podem&nbsp;confundir&nbsp;o&nbsp;adversário.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;if&nbsp;(interval&nbsp;==&nbsp;5)</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;score;&nbsp;//&nbsp;há&nbsp;potencial&nbsp;nesta&nbsp;direção</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;else</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;{</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;//&nbsp;não&nbsp;há&nbsp;casas&nbsp;suficientes&nbsp;nesta&nbsp;direção&nbsp;para&nbsp;fechar&nbsp;o&nbsp;jogo.</span></span></div><div class="line"><span class="text plain null-grammar"><span>&nbsp;&nbsp;}</span></span></div><div class="line"><span class="text plain null-grammar"><span>}</span></span></div></pre>
<p>O algoritmo acima está basicamente fazendo o seguinte:</p>
<ol>
<li>Cada casa adjacente é percorrida numa direção até se alcançar um intervalo de 5 casas.</li>
<li>Para cada casa vazia, somasse 50 à pontuação inicial, pois se trata de uma marca em potencial para o jogador, mas pode não ser concretizada.</li>
<li>Para cada casa marcada com o marcador de jogada passado como paramêtro, somasse 100 à pontuação, pois o jogador já garantiu esta casa para a formação de sua linha.</li>
<li>Casa marcada com o marcador do adversário (ou se chegou no final do tabuleiro) faz a busca seguir no sentido contrário e perdesse um ponto por ser uma linha bloqueada em uma das pontas. Se uma direção for bloqueada já na casa da jogada, então o sentido contrário nem é percorrido, porque já vai ser coberto pela pontuação da direção oposta.</li>
<li>Ganhasse um ponto caso a linha seja tracejada. Esta deve valer mais que uma linha contínua porque ela pode confundir o adversário fazendo não perceber que se está perto de fechar uma linha.</li>
</ol>
<p>Observe que este algoritmo percorre todas as direções e somente escolhe a pontuação maior, ao invés de somar o valor de cada direção. Isto é porque este algoritmo tenta de certa forma simular o que aconteceria caso a árvore de busca fosse percorrida pelo algoritmo min-max, onde também se escolhe a pontuação máxima dos nós-filho. Pode-se dizer que este algoritmo é uma localização da busca min-max sem precisar percorrer a árvore de estados do tabuleiro.</p>
<h2 id="an-lise-da-efetividade-da-fun-o-de-pontua-o">Análise da Efetividade da Função de Pontuação</h2>
<p>Dado o algoritmo acima, vamos analisar como ele se comporta diante de alguns cenários do jogo Gomoku abordados pelas heurísticas definidas anteriormente.</p>
<h3 id="campo-limpo">Campo Limpo</h3>
<p>Num cenário de começo de jogo quando o campo está limpo, uma casa no centro do tabuleiro vai atingir uma pontuação mais alta que uma casa nas bordas do tabuleiro, pois uma casa do centro pode pontuar em todas as direções.</p>
<h3 id="pontas-livres">Pontas Livres</h3>
<p>Uma casa que forma uma linha com pontas livres irá pontuar mais que uma casa que possui bloqueio em algumas das pontas, porque a última será penalidade com a diminuição da pontuação quando um bloqueio for encontrado.</p>
<h3 id="triangula-o">Triangulação</h3>
<p>Uma casa que faz parte de várias linhas em direções diferentes vai pontuar mais alto que uma casa participando de apenas uma linha, porque para cada valor máximo repetido numa direção geração pontuação de &quot;gratificação&quot; para aquela casa.</p>
<h3 id="tracejando">Tracejando</h3>
<p>Linhas com alternância de marcador e casas vazias são gratificas e pontuam mais que uma linha com o mesmo número de marcadores em sequência.</p>
<h3 id="sentinela">Sentinela</h3>
<p>O cenário em que o adversário estas prestes a completar uma linha de quatro casas com duas pontas livres é coberto por aspectos do algoritmo descritos abaixo:</p>
<ul>
<li>Primeiramente, a pontuação das jogadas simuladas com o adversário jogando na mesma posição são comparadas na função de utilidade da mesma forma que uma jogada do computador. Desta forma, se a jogada do adversário se torna mais vantajosa a este do que outra jogada do computador, então o computador jogará na casa que traria vantagem ao adversário para lhe impedir de fazê-la.</li>
<li>Além disso, como descrito na seção Pontas Livres, as jogadas que forem bloqueadas em uma das pontas serão penalizadas, portanto a jogada do adversário que tem pontas livres terá pontuação maior que qualquer outra jogada do computador que tenha bloqueios. Assim o computador vai acabar jogando na posição queria traria pontas livres para o adversário.</li>
</ul>
<h3 id="bloqueio-amplo">Bloqueio Amplo</h3>
<p>Assim como foi descrito na Triangulação, cada valor máximo repetido em uma casa é gratificado, mesmo quando calculando um cenário de jogada do adversário. Assim, uma posição de múltiplos bloqueios terá precedência sobre uma posição onde o computador fazendo um único bloqueio.</p>
<h3 id="combina-o-de-cen-rios">Combinação de Cenários</h3>
<p>Na segunda parte do trabalho, a intenção é fazer também uma análise da combinação de diferentes cenários (por exemplo, Bloqueio Amplo vs Pontas Livres) e verificar se o algoritmo ainda continua fazendo as melhores escolhas.</p>
<h2 id="otimiza-es">Otimizações</h2>
<p>Visto que a busca do min-max é proibitiva num tabuleiro 15x15, devido ao tamanho da árvore gerada para todos os estados do jogo, é importante considerar formas de otimização que permitam diminuir a árvore de busca. Isto tornaria viável buscas em níveis mais baixos da árvore, quem sabe até permitindo a busca alcançar os nós terminais, assim evitando o uso das heurísticas da função de utilidade.</p>
<h3 id="podas-com-alpha-beta">Podas com Alpha &amp; Beta</h3>
<p>O algoritmo min-max que mantém valores de alpha e beta para cada nó permite que ramos inteiros da árvore de busca possam ser ignorados, pois estes não poderiam em tese trazer resultados melhores do que já se alcançou com os ramos já pesquisados.</p>
<p>Na parte 2 do trabalho, a intenção é modificar a implementação inicial do algoritmo min-max, introduzindo podas, e verificar se foi o suficiente para aumentar a profundidade da busca.</p>
<h3 id="foco-em-reas-do-tabuleiro">Foco em Áreas do Tabuleiro</h3>
<p>Outra abordagem que tentaremos na segunda parte do trabalho é limitar a busca a uma área menor do tabuleiro. Se o jogo num determinado momento se concentra na área central do tabuleiro, por exemplo, então a busca poderia criar uma área central menor (vamos dizer, de 8x8) e então fazer a busca somente nos estados gerados dentro desta área.</p>
<p>No início do jogo, quando ainda existem poucas áreas marcadas, esta abordagem poder ser muito efetiva. Porém, a medida que o adversário começa a marcar áreas novas do tabuleiro, é necessário avaliá-las. Talvez seja possível manter várias áreas de busca separadas, dependendo da distância entre elas.</p>
<hr></body>
</html>
